\chapter{Algorithm}
\label{ch:alg}

%TODO: Graphics of shift invariant distance, closest match, etc.

%TODO. chapter references
In this chapter, I describe the practical implementation of the method described
in Chapter \ref{ch:method}.

% Assume we have the normalize and sliced signals already and just talk about
% detection.
\section{Overview}

The goal of the algorithm is to perform online classification of an infinite
stream of samples from an observed digital signal. We will focus on the case of
binary classification, in which we have positive signals and negative signals,
but the results can be extended to multiple classes.  For binary classification,
one could imagine that one class represents events and the other non-events, and
that we would like to detect events as soon as they happen.

To predict which class the observed signal belongs to at a given point in time,
we compute the probability that the recent samples of the observed signal were
generated by a ``positive'' process and the probability that they were generate
by a ``negative'' process, based on previously observed positive and negative
{\em reference signals}. Recall from Chapter \ref{ch:method} that a signal is
generated by a particular type of process if it shares the same latent process
as a signal of that type. To compute the probability that the recently observed
samples share the same process with a particular reference signal, we compute
the distance between the trajectory consisting of the recently observed samples
and all trajectories of the same size in the reference signal, and take the
minimum over all such trajectories.

% TODO: Justification for shift-invariance.

\section{Implementation}

As in Chapter \ref{ch:method}, let $\mb s$ be the most recent $N_{obs}$ samples of the
infinite observed signal $\mb s_{\infty}$ and let $\mb r$ be a reference signal
of length $N_{ref}$.

\begin{algorithm}
\caption{Perform online binary classification on an observed signal
    using sets of positive and negative reference signals $R_+$ and $R_-$.}
\label{alg:Detect}
\at{Detect}($\mb s_{\infty}$, $\mathcal{R}_+$, $\mathcal{R}_-$, $\gamma$, $\theta$,
$D_{req}$):
\begin{algorithmic}[1]
\STATE \vt{ConsecutiveDetections} $\leftarrow$ 0
\LOOP
  \STATE $\mb s$ $\leftarrow$ \at{UpdateObservation}($\mb s_{\infty}$, $N_{obs}$)
  \FOR{$\mb r$ {\bf in} $\mathcal{R}_+$}
    \STATE \vt{PosDists}.\at{Append}(\at{DistToReference}($\mb s$, $\mb r$))
  \ENDFOR
  \FOR{$\mb r$ {\bf in} $\mathcal{R}_-$}
    \STATE \vt{NegDists}.\at{Append}(\at{DistToReference}($\mb s$, $\mb r$))
  \ENDFOR
  \STATE \vt{R} = \at{ProbClass}(\vt{PosDists}) / \at{ProbClass}(\vt{NegDists})
  \IF{\vt{R} $> \theta$ }
    \IF{\vt{ConsecutiveDetections} $>$ $D_{req}$}
      \STATE \vt{DetectionTime} $\leftarrow$ \at{CurrentTime}()
      \RETURN \vt{DetectionTime}
    \ELSE
      \STATE \vt{ConsecutiveDetections} $\leftarrow$ \vt{ConsecutiveDetections} + 1
    \ENDIF
  \ELSE
    \STATE \vt{ConsecutiveDetections} $\leftarrow$ 0
  \ENDIF
\ENDLOOP
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Compute the minimum distance between $\mb s$ and all pieces of $\mb r$
  of the same length as $\mb s$.}
\label{alg:DistToReference}
\at{DistToReference}($\mb s$, $\mb r$):
\begin{algorithmic}[1]
  \STATE $N_{obs}$ $\leftarrow$ \at{length}($\mb s$)
  \STATE $N_{ref}$ $\leftarrow$ \at{length}($\mb r$)
  \STATE \vt{MinDist} = $\infty$
  \FOR{$i=1$ \TO $N_{ref} - N_{obs} + 1$}
    \STATE \vt{MinDist} = \at{Min}(\vt{MinDist}, \at{Dist}($\mb r_{i:i+N_{obs}-1}$, $\mb s$))
  \ENDFOR
  \RETURN \vt{MinDist}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Compute the distance between two signals $\mb s$ and $\mb t$ of the same
    length}
\label{alg:DistToSignal}
\at{Dist}($\mb s$, $\mb t$):
\begin{algorithmic}[1]
\STATE \vt{D} $\leftarrow$ 0
\FOR{$i=1$ to \at{length}($\mb s$)}
  \STATE \vt{D} $\leftarrow$ \vt{D} + $(s_i - t_i)^2$
\ENDFOR
\RETURN \vt{D}
\end{algorithmic}
\end{algorithm}
